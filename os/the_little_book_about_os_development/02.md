# 02 - First Steps

## tool

```bash
# for fedora
fedora:~ # dnf install @development-tools nasm genisoimage bochs bochs-sdl

# for ubuntu
ubuntu:~ # apt-get install build-essential nasm genisoimage bochs bochs-sdl
```

## language

- \_\_attribute\_\_((packed)):

是 GCC 提供的特定屬性（attribute），用來確保結構體（struct）的記憶體佈局完全按照定義的方式排列，而不會被編譯器自動填充（padding）。在 C 語言中，編譯器通常會自動對齊（alignment）結構體內的成員，以提高存取效率。但有時候，特定的應用（如作業系統開發、嵌入式系統、通訊協議）需要確保結構體的記憶體佈局與預期完全一致，因此需要 \_\_attribute\_\_((packed)) 來禁止編譯器填充額外的位元組。

```c
#include <stdio.h>

struct NormalStruct {
    char a;    // 1 byte
    int b;     // 4 bytes (通常會對齊到 4-byte 邊界)
};

int main() {
    printf("Size of NormalStruct: %lu\n", sizeof(struct NormalStruct));
    return 0;
}

// Size of NormalStruct: 8

// 記憶體佈局
// | a | - | - | - | b | b | b | b |
```

```c
#include <stdio.h>

struct PackedStruct {
    char a;    // 1 byte
    int b;     // 4 bytes（不對齊）
} __attribute__((packed));

int main() {
    printf("Size of PackedStruct: %lu\n", sizeof(struct PackedStruct));
    return 0;
}

// Size of NormalStruct: 5

// 記憶體佈局
// | a | b | b | b | b |
```

適用情境

1. OS Kernel 開發：作業系統需要確保結構體的記憶體佈局與硬體或 BIOS 結構相符。
2. 通訊協議：例如 TCP/IP、USB、PCIe 等協議有固定的資料格式。
3. 嵌入式系統：直接與記憶體映射硬體溝通時，必須確保資料佈局符合硬體要求。

- stack

某些部分的作業系統（OS）程式碼必須用組合語言（assembly）編寫，因為 C 語言需要依賴堆疊（stack），但在 OS 啟動的早期階段，堆疊還未建立，因此無法直接使用 C 語言。
當 CPU 啟動時，它並沒有自動配置好堆疊記憶體，而 C 語言的函式調用機制（例如 push 參數、return 值、局部變數）都依賴於堆疊。因此，在 OS 的啟動階段，我們通常必須使用 組合語言 來手動初始化堆疊，然後才能進入 C 語言程式碼。

## example

- loader.asm

```asm
; loader.asm
    global loader                   ; the entry symbol for ELF

    MAGIC_NUMBER equ 0x1BADB002     ; define the magic number constant
    FLAGS        equ 0x0            ; multiboot flags
    CHECKSUM     equ -MAGIC_NUMBER  ; calculate the checksum
                                    ; (magic number + checksum + flags should equal 0)

    section .text:                  ; start of the text (code) section
    align 4                         ; the code must be 4 byte aligned
        dd MAGIC_NUMBER             ; write the magic number to the machine code,
        dd FLAGS                    ; the flags,
        dd CHECKSUM                 ; and the checksum

    loader:                         ; the loader label (defined as entry point in linker script)
        mov eax, 0xCAFEBABE         ; place the number 0xCAFEBABE in the register eax
    .loop:
        jmp .loop                   ; loop forever
```

- link.ld

```ld
/* link.ld */
ENTRY(loader)                /* the name of the entry label */

SECTIONS {
    . = 0x00100000;          /* the code should be loaded at 1 MB */

    .text ALIGN (0x1000) :   /* align at 4 KB */
    {
        *(.text)             /* all text sections from all files */
    }

    .rodata ALIGN (0x1000) : /* align at 4 KB */
    {
        *(.rodata*)          /* all read-only data sections from all files */
    }

    .data ALIGN (0x1000) :   /* align at 4 KB */
    {
        *(.data)             /* all data sections from all files */
    }

    .bss ALIGN (0x1000) :    /* align at 4 KB */
    {
        *(COMMON)            /* all COMMON sections from all files */
        *(.bss)              /* all bss sections from all files */
    }
}
```

- compile

```bash
# compile
linux:~ # nasm -f elf32 loader.asm
linux:~ # ld -T link.ld -melf_i386 loader.o -o kernel.elf

# check
linux:~ # file kernel.elf
linux:~ # readelf -f kernel.elf
```

- grub

```bash
# grub
linux:~ # curl -OL https://github.com/littleosbook/littleosbook/raw/refs/heads/master/files/stage2_eltorito
linux:~ # mkdir -p iso/boot/grub              # create the folder structure
linux:~ # cp stage2_eltorito iso/boot/grub/   # copy the bootloader
linux:~ # cp kernel.elf iso/boot/             # copy the kernel

linux:~ # vi iso/boot/grub/menu.lst
default=0
timeout=0

title os
kernel /boot/kernel.elf

linux:~ # tree iso
iso
└── boot
    ├── grub
    │   ├── menu.lst
    │   └── stage2_eltorito
    └── kernel.elf

2 directories, 3 files

linux:~ # genisoimage -R \
  -b boot/grub/stage2_eltorito \
  -no-emul-boot \
  -boot-load-size 4 \
  -A os \
  -input-charset utf8 \
  -quiet \
  -boot-info-table \
  -o os.iso \
  iso
```

- emulator

```bash
linux:~ # qemu-system-i386 -cdrom os.iso -nographic -serial mon:stdio
Ctrl + a, c
(qemu) info registers
EAX=cafebabe
```
