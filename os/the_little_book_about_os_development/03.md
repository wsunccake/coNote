# 03 - Getting to C

## calling c code from assembly

- example

```asm
; main.asm
section .text
    global main
    extern sum_of_three
    extern print_result

main:
    push rbp
    mov rbp, rsp

    ; 依照 cdecl 風格，從右到左 push 參數
    push 3            ; arg3
    push 2            ; arg2
    push 1            ; arg1

    ; 從堆疊中提取參數到正確的暫存器 (System V AMD64 ABI)
    pop rdi           ; 第一個參數 arg1 = 1
    pop rsi           ; 第二個參數 arg2 = 2
    pop rdx           ; 第三個參數 arg3 = 3

    ; 呼叫 C 函數 sum_of_three
    call sum_of_three

    ; 傳遞返回值給 print_result
    mov rdi, rax
    call print_result

    ; 結束程式
    mov eax, 0
    pop rbp
    ret
```

```c
// sum.c
#include <stdio.h>

int sum_of_three(int arg1, int arg2, int arg3) {
    return arg1 + arg2 + arg3;
}

void print_result(int result) {
    printf("Sum: %d\n", result);
}
```

```bash
linux:~ $ gcc -m64 -c sum.c -o sum.o
linux:~ $ nasm -f elf64 main.asm -o main.o
linux:~ $ gcc sum.o main.o -o sum
linux:~ $ ./sum
```

## 32-bit

```asm
loader.asm
global loader                   ; the entry symbol for ELF

    MAGIC_NUMBER equ 0x1BADB002     ; define the magic number constant
    FLAGS        equ 0x0            ; multiboot flags
    CHECKSUM     equ -MAGIC_NUMBER  ; calculate the checksum
                                    ; (magic number + checksum + flags should equal 0)

    KERNEL_STACK_SIZE equ 4096      ; size of stack in bytes

    section .bss
    align 4                         ; align at 4 bytes
    kernel_stack:                   ; label points to beginning of memory
        resb KERNEL_STACK_SIZE      ; reserve stack for the kernel

    section .text:                  ; start of the text (code) section
    align 4                         ; the code must be 4 byte aligned
        dd MAGIC_NUMBER             ; write the magic number to the machine code,
        dd FLAGS                    ; the flags,
        dd CHECKSUM                 ; and the checksum

    loader:                                             ; the loader label (defined as entry point in linker script)
    mov esp, kernel_stack + KERNEL_STACK_SIZE           ; point esp to the start of the
                                                        ; stack (end of memory area)

    ; The assembly code
    extern sum_of_three                   ; the function sum_of_three is defined elsewhere
    push dword 3                          ; arg3
    push dword 2                          ; arg2
    push dword 1                          ; arg1
    call sum_of_three                   ; call the function, the result will be in eax


    .loop:
        jmp .loop                   ; loop forever
```

```c
// kmain.c
/* The C function */
int sum_of_three(int arg1, int arg2, int arg3)
{
    return arg1 + arg2 + arg3;
}
```

```makefile
OBJECTS = loader.o kmain.o
CC = gcc
CFLAGS = -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \
         -nostartfiles -nodefaultlibs -Wall -Wextra -Werror -c
LDFLAGS = -T link.ld -melf_i386
AS = nasm
ASFLAGS = -f elf

all: kernel.elf

kernel.elf: $(OBJECTS)
        ld $(LDFLAGS) $(OBJECTS) -o kernel.elf

os.iso: kernel.elf
        cp kernel.elf iso/boot/kernel.elf
        genisoimage -R                              \
                    -b boot/grub/stage2_eltorito    \
                    -no-emul-boot                   \
                    -boot-load-size 4               \
                    -A os                           \
                    -input-charset utf8             \
                    -quiet                          \
                    -boot-info-table                \
                    -o os.iso                       \
                    iso

run: os.iso
        qemu-system-i386 -cdrom os.iso -nographic -serial mon:stdio

%.o: %.c
        $(CC) $(CFLAGS)  $< -o $@

%.o: %.asm
        $(AS) $(ASFLAGS) $< -o $@

clean:
        rm -rf *.o kernel.elf os.iso iso/boot/kernel.elf
```

```
1. 目標架構
-m32：強制使用 32 位元模式進行編譯（適用於 x86 架構，前提是你的 GCC 支援 32 位元目標）。

2. 禁用標準函式庫與標頭
-nostdlib：不連結標準 C 函式庫（libc），也不包含 crt 啟動程式碼（如 crt0.o）。
-nostdinc：不包含標準 C 標頭檔（如 <stdio.h>、<stdlib.h>）。

3. 禁用 GCC 內建函式與安全機制
-fno-builtin：停用所有 GCC 內建函式（例如 memcpy、strlen 等），確保你只能使用自己提供的函式。
-fno-stack-protector：禁用 Stack Protector，避免額外的安全檢查（這些檢查通常由 libssp 提供，在裸機環境不適用）。

4. 不使用標準的啟動文件與預設函式庫
-nostartfiles：不連結標準的啟動程式碼（例如 crt0.o），適用於自製 OS Kernel 或 bootloader。
-nodefaultlibs：不連結標準函式庫（如 libc、libm），因為在裸機開發時可能不需要它們。

5. 警告與錯誤處理
-Wall：開啟所有常見警告。
-Wextra：啟用額外的警告（比 -Wall 更多）。
-Werror：將所有警告視為錯誤，確保編譯過程中沒有遺漏的問題。

6. 產生目標檔案（不連結）
-c：只進行編譯（compile），不進行連結（linking），會產生 .o 物件檔。
```

```bash
linux:~ # qemu-system-i386 -cdrom os.iso -nographic -serial mon:stdio
Ctrl + a, c
(qemu) info registers
EAX=00000006
...
```

---

## 64-bit

- boot.asm

```asm
global loader                   ; 內核入口點，對應 linker script 的 `_start`
extern kernel_main              ; C 內核的主函式

section .multiboot
align 8
    dd 0xE85250D6               ; Multiboot 2 magic number
    dd 0                        ; Architecture (x86-64)
    dd 24                       ; Header length
    dd -(0xE85250D6 + 0 + 24)   ; Checksum

section .bss
align 8
kernel_stack:
    resb 4096                   ; 保留 4KB 堆疊

section .text
align 8
loader:
    cli                         ; 關閉中斷
    mov rsp, kernel_stack + 4096 ; 設定 64 位元堆疊
    call kernel_main            ; 呼叫 C 內核主函式

.loop:
    hlt                         ; 讓 CPU 進入休眠狀態
    jmp .loop                   ; 無限迴圈
```

- kernel.c

```c
#include <stdint.h>

void kernel_main() {
    const char *str = "Hello, Kernel!\n";
    volatile uint16_t *vga = (uint16_t*)0xB8000;

    for (int i = 0; str[i] != '\0'; i++) {
        vga[i] = (uint16_t) str[i] | (0x0F << 8);
    }

    while (1) {
        __asm__ volatile ("hlt");
    }
}
```

- linker.ld

```ld
ENTRY(loader)

SECTIONS {
    . = 1M;

    .multiboot2 ALIGN(8) : {
        *(.multiboot)
    }

    .text ALIGN(4K) : {
        *(.text)
    }

    .rodata ALIGN(4K) : {
        *(.rodata)
    }

    .data ALIGN(4K) : {
        *(.data)
    }

    .bss ALIGN(4K) : {
        *(COMMON)
        *(.bss)
    }
}
```

- grub.cfg

```cfg
set timeout=0
set default=0

menuentry "My 64-bit Kernel" {
    multiboot2 /boot/kernel.elf
    boot
}
```

```bash
linux:~ # mkdir -p iso/boot/grub
linux:~ # cp grub.cfg iso/boot/grub

linux:~ # nasm -f elf64 boot.asm -o boot.o
linux:~ # gcc -ffreestanding -mno-red-zone -m64 -c kernel.c -o kernel.o
linux:~ # ld -T linker.ld -melf_x86_64 boot.o kernel.o -o iso/boot/kernel.elf

linux:~ # grub-mkrescue -o os.iso iso

linux:~ # qemu-system-x86_64 -cdrom os.iso -nographic -serial mon:stdio
```

---

## 暫存器 / Register

暫存器是 CPU 內部的一小塊高速記憶體，用於暫存數據與指令，以便 CPU 快速存取。暫存器的存取速度比 RAM（隨機存取記憶體）快得多，通常用於處理運算、邏輯判斷、地址運算等關鍵任務。

1. 通用暫存器（General-Purpose Registers, GPRs）

這些暫存器可用於數值運算、資料儲存、記憶體地址計算等。

| 32 bit / x86 | 64 bit / x86-64 | 用途                                      |
| ------------ | --------------- | ----------------------------------------- |
| EAX          | RAX             | 累加器（Accumulator），用於算術與邏輯運算 |
| EBX          | RBX             | 基址（Base），有時用於存儲地址            |
| ECX          | RCX             | 計數器（Counter），常用於迴圈計數         |
| EDX          | RDX             | 資料暫存器（Data），可用於乘法與 I/O 操作 |

在 16 位元（x86 real mode）時，這些暫存器的名稱是 AX、BX、CX、DX，並且可以分為 8 位元低、高位元部分，例如：
AH / AL（AX 的高 / 低 8 位元）、BH / BL、CH / CL、DH / DL 同理。

2. 指標與索引暫存器

這些暫存器主要用於存取記憶體或指向堆疊（Stack）。

| 32 bit / x86 | 64 bit / x86-64 | 用途                                          |
| ------------ | --------------- | --------------------------------------------- |
| ESP          | RSP             | 堆疊指標（Stack Pointer），指向堆疊頂部       |
| EBP          | RBP             | 基底指標（Base Pointer），用於函式的堆疊框架  |
| ESI          | RSI             | 原索引（Source Index），常用於字串操作        |
| EDI          | RDI             | 目的索引（Destination Index），常用於字串操作 |

這些暫存器在 MOVS, LODS, STOS 等字串操作指令中經常被使用。

3. 控制暫存器 / Control Registers

控制 CPU 的操作模式，影響記憶體管理、安全性等。

| 暫存器 | 用途                                        |
| ------ | ------------------------------------------- |
| CR0    | 控制 CPU 運行模式（如啟用/禁用分頁模式）    |
| CR2    | CR2 存放 Page Fault（分頁錯誤）時的錯誤位址 |
| CR3    | CR3 存放頁表基址（用於分頁機制）            |
| CR4    | CR4 控制 CPU 進階功能（如 PAE, SSE）        |

4. 段暫存器 / Segment Registers

在 16 位元模式（如 Real Mode）中，用於分段記憶體管理，但在 32/64 位元模式下用得較少。

| 暫存器     | 用途                                         |
| ---------- | -------------------------------------------- |
| CS         | 代碼段（Code Segment），存放程式指令         |
| DS         | 資料段（Data Segment），存放資料             |
| SS         | 堆疊段（Stack Segment），存放堆疊            |
| ES, FS, GS | 額外段（Extra Segments），可用於存取特定資料 |

在 64 位元模式下，大多數段暫存器的功能被弱化或棄用，除了 FS 和 GS 還可用於存放 Thread Local Storage（TLS）等特殊用途。

5. 狀態標誌暫存器（Flags Register / EFLAGS / RFLAGS）

這是一組用於表示 CPU 當前狀態的標誌位，例如：

- ZF（Zero Flag）：結果為 0 時設置
- CF（Carry Flag）：進位標誌
- SF（Sign Flag）：負號標誌
- OF（Overflow Flag）：溢出標誌

這些標誌位在條件跳轉（如 JZ, JNZ, JC, JNC）時特別有用。

6. SIMD 暫存器（浮點與向量運算）

現代 CPU 具有專門的暫存器來加速數據處理，如：

- MMX（MM0–MM7）：Intel MMX 技術的 64 位元暫存器
- XMM（XMM0–XMM15）：128 位元，用於 SSE（Streaming SIMD Extensions）
- YMM（YMM0–YMM31）：256 位元，用於 AVX（Advanced Vector Extensions）
- ZMM（ZMM0–ZMM31）：512 位元，用於 AVX-512

這些暫存器在圖形運算、機器學習、影片編碼等應用中極為重要。
