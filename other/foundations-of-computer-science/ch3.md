# ch3 數字系統與資料表示法

## 3-1 電腦的資料基本單位

```
8 bit = 1 Btye

Kilo Byte / KB => 2^10 Bytes = 1,024 Bytes
Mega Byte / MB => 2^20 Bytes = 1,048,576 Bytes
Giga Byte / GB => 2^30 Bytes = 1,073,741,824 Bytes
Tera Byte / TB => 2^40 Bytes = 1,099,511,627,776 Bytes
Peta Byte / PB => 2^50 Bytes = 1,125,899,906,842,624 Bytes
Exa  Byte / EB => 2^60 Bytes = 1,152,921,504,606,846,976 Bytes
```

---

## 3-2 數字系統轉換

二進位系統 binary system
八進位系統 octal system
十六進位系統 hexadecimal system

```
# binary to decimal
1011.11(2) = 11.75(10)
1 * 2^3         8
 0 * 2^2        0
  1 * 2^1       2
   1 * 2^0      1
     1 * 2^-1   0.5
      1 * 2^-2  0.25
               11.75

# octal to decimal
123.64(8) = 83.8125(10)
1 * 8^2         64
 2 * 8^1        16
  3 * 8^0        3
    6 * 8^-1     0.75
     4 * 8^-2    0.0625
                83.8125
```

```
# decimal to binary
11.75(10) = 1011.11(2)
11 / 2 = 5 ... 1 -------- |
 5 / 2 = 2 ... 1 ------- ||
 2 / 2 = 1 ... 0 ------ |||
 0 / 2 = 0 ... 1 ----- ||||
                    => 1011.11
                            ||
0.75 * 2 = 1.5 = 0.5 + 1 -- ||
0.5  * 2 = 1.0 = 0.0 + 1 --- |

# decimal to octal
83.8125(10) = 123.64(8)
83 / 8 = 10 ... 3 ------- |
10 / 8 =  1 ... 2 ------ ||
 1 / 8 =  0 ... 1 ----- |||
                        123.64
                            ||
.8125 * 8 = 6.5 = .5 + 6 -- ||
.5    * 8 = 4.0 = .0 + 4 ----|
```

```
# binary to octal
10011(2) = 23(8)
   010 011
=>   2   3  = 23

# binary to octal
23(8) = 10011(2)
     2 3
=> 010 011  = 010011
```

---

## 3-3 整數表示法

無符號整數 / unsigned integer

符號整數 / signed integer

```
# 8 bit unsigned integer
bit        ~ unsigned integer/ decimal
0000 0000  ~    0
0000 0001  ~    1
...
1111 1110  ~  254
1111 1111  ~  255
```

### 1's complement / 1 補數

- 該數取 not, 為其補數, c = ~n
- 該數 + 補數 = -0
- 有 -0 (多佔用 1 bit)

```
# 8 bit signed integer
bit        ~ signed integer/ decimal
0000 0000  ~    0
0000 0001  ~    1
...
0111 1111  ~  127

1111 1111  ~   -0
1111 1110  ~   -1
...
1000 0000  ~ -127
```

### 2's complement / 2 補數

- 該數取 not + 1, 為其補數, c = ~n + 1
- 該數 + 補數 = 0
- 沒有 -0

```
# 8 bit signed integer
bit        ~ signed integer/ decimal
0000 0000  ~    0
0000 0001  ~    1
...
0111 1111  ~  127

              沒有 -0
1111 1111  ~   -1
...
1000 0000  ~ -127
```

### diminished radix complement / 縮減基底補數 / (K-1)'s 補數

```
3542(10) 9's 補數 => 6457(10)

= [10^4(10) - 1] - 3542(10)
= 9999(10) - 3542(10)
= 6457(10)
```

```
12.34(8)  7's 補數 =>  65.43(8)

= [10^2(8) - 10^-2(8)] - 12.34(8)
= [100.00(8) - 0.01(8)] - 12.34(8)
= 77.77(8) - 12.34(8)
= 65.43(8)
```

### radix complement / 基底補數 / K's 補數

```
12.34(8)  8's 補數 =>  65.44(8)

= 10^2(8) - 12.34(8)
= 100.00(8) - 12.34(8)
=  65.44(8)
```

---

## 3-4 數值算術運算

---

## 3-5 數碼系統

### 3-5-1 BCD 碼 / binary coded decimal

每個十進制數字（0-9）都由四位二進制數來表示

```
decimal     BCD
                 8421
    0            0000
    1            0001
    2            0010
    3            0011
    4            0100
    5            0101
    6            0110
    7            0111
    8            1000
    9            1001

   12       0001 0010
        =>     1    2
```

- 易於轉換
  BCD 編碼與十進制之間的轉換非常簡單，因為每個十進制數字直接映射為一個 4 位二進制數

- 冗餘度高
  與純二進制表示相比，BCD 編碼比較冗餘，效率較低。每個 4 位二進制數只能表示 0-9，而二進制 4 位數其實可以表示 0-15

- 應用場景
  BCD 常用於需要簡單直觀顯示十進制數字的場合，如數字時鐘、計算器的顯示屏

BCD 編碼的主要優勢在於，它使得在硬體或軟體中處理和顯示十進制數字更加簡單直觀

### 3-5-2 2421 碼

```
decimal
                 2421
    0            0000
    1            0001
    2            0010
    3            0011
    4            0100
    5            0101
    6            0110
    7            0111
    8            1110
    9            1111
```

- 錯誤檢測能力
  由於每個十進制數字都有特定的編碼，2421 碼在某些情況下具有一定的錯誤檢測能力，可以幫助檢測數據傳輸中的錯誤

- 應用場景
  2421 碼主要用於特定的數字電路或數據通信系統中，特別是在需要加權編碼的場景中

### 3-5-3 84-2-1 碼

```
decimal           -2
                   -1
                 84
    0            0000
    1            0111
    2            0110
    3            0101
    4            0100
    5            1011
    6            1010
    7            1001
    8            1000
    9            1001
```

- 負權值
  84-2-1 碼是加權碼中少數具有負權值的編碼。這種編碼方式的設計使得在某些應用中可以更加靈活地表示數字
- 應用場景
  84-2-1 碼主要用於特定的數字電路中，尤其是在需要特殊二進制表示的地方。

84-2-1 碼的設計為數字的二進制表示提供了一種有趣的方式，特別是在需要負權值來達到某些特定計算或表示要求的情況下

### 3-5-4 超三碼 / Excess-3 code

```
decimal           -2
                   -1
                 84
   -3            0000
   -2            0001
   -1            0010
    0            0011
    1            0100
    2            0101
    3            0110
    4            0111
    5            1000
    6            1001
    7            1010
    8            1011
    9            1100
```

- 簡化運算
  由於加了偏移量 3，超三碼避免了 BCD 碼中的進位問題，使得一些數字運算（如加法）變得更加簡單
- 錯誤檢測
  在某些情況下，超三碼可以幫助檢測數據傳輸過程中的錯誤，因為它與自然二進制存在系統偏移
- 應用場景
  超三碼主要應用於早期的數字系統和某些特殊的計算機設計中，特別是在簡化電路或數據處理的需求中

超三碼提供了一種將十進制數字轉換為二進制的獨特方式，通過增加一個偏移量，使得編碼過程更加靈活並且在某些應用中更為有效。

### 3-5-5 二五碼 / Biquinary code

```
decimal
                 五進位
                 __
                   二進位
                   ＿＿＿
    0            0100001
    1            0100010
    2            0100100
    3            0101000
    4            0110000
    5            1000001
    6            1000010
    7            1000100
    8            1001000
    9            1010000
```

- 錯誤檢測
  Biquinary 碼具有一定的錯誤檢測能力，因為它將十進制數分解為兩部分來表示。這使得在數據傳輸或存儲過程中，錯誤可以被更容易地檢測到

- 歷史應用
  Biquinary 碼在一些早期的計算機系統中得到了應用，特別是在需要高可靠性的情況下，例如 IBM 650 等計算設備

儘管如今已不再廣泛使用，Biquinary 碼仍然是計算機科學歷史上一個有趣的編碼方案，它展示了如何通過結合二進制和五進制來有效地表示十進制數字

### 3-5-6 五取二碼 / 2-out-of 5 code

```
decimal
    0            00011
    1            00101
    2            00110
    3            01001
    4            01010
    5            01100
    6            10001
    7            10010
    8            10100
    9            11000
```

- 錯誤檢測能力
  2-out-of-5 碼具有一定的錯誤檢測能力。由於每個編碼組合都有兩個「1」，這使得錯誤的數據或損壞的數據很容易被檢測到

- 簡單的數字表示
  這種編碼方式簡單易懂，適合用於需要可靠數字識別的場景

2-out-of-5 碼常見於條碼系統、票據處理系統和早期的數字計算設備中 總的來說，2-out-of-5 碼是一種直觀且有效的編碼方式，具有一定的錯誤檢測能力，適用於各種需要精確數字表示的應用場景

### 3-5-7 葛雷碼 / gray code

```
3 bit
decimal      binary         gray
0  　　       000            000
1  　　       001            001
2   　　      010            011
3   　　      011            010
4   　　      100            110
5   　　      101            111
6   　　      110            101
7   　　      111            100

4 bit
decimal      binary         gray
0            0000           0000
1            0001           0001
2            0010           0011
3            0011           0010
4            0100           0110
5            0101           0111
6            0110           0101
7            0111           0100
8            1000           1100
9            1001           1101
10           1010           1111
11           1011           1110
12           1100           1010
13           1101           1011
14           1110           1001
15           1111           1000
```

```
G0           G1          G2
0       0 0  00    0 00  000
1       0 1  01    0 01  001
        1 1  11    0 11  011
        1 0  10    0 10  010
                   1 10  110
                   1 11  111
                   1 01  101
                   1 00  100

0  +----- 0   00   00
1  |  +-- 1   01   01
   |  +-- 1   11   11
   |----- 0   10   10
                   10
                   11
                   01
                   00
```

`特性`

- 最小變化性
  在葛雷碼中，相鄰的兩個碼字之間只有一位二進制位發生變化，這一特性使其特別適合於模數轉換和旋轉編碼器等需要避免數據讀取錯誤的場合

- 無重複性
  每個數字在葛雷碼中都有唯一的表示，不會與其他數字混淆

`應用`

- 旋轉編碼器
  在機械旋轉編碼器中，使用葛雷碼可以避免由於同步錯誤導致的位置讀取錯誤。

- 模數轉換器 / ADC
  在模數轉換過程中，使用葛雷碼可以減少由於位切換引起的噪聲和誤差，從而提高數據讀取的準確性

- 數位電路設計
  在某些數位電路設計中，為了避免快速變化引起的錯誤信號，使用葛雷碼來設計狀態機的狀態轉移是常見的做法

`優點`

- 錯誤最小化
  相鄰碼字之間只有一位變化，這在硬體實現和讀取時能有效減少錯誤

- 適用性廣
  在模數轉換、旋轉編碼等需要精確度和抗干擾能力的場合，葛雷碼表現優秀

`缺點`

- 轉換複雜度
  將二進制碼轉換為葛雷碼，或從葛雷碼轉回二進制碼，需要額外的運算步驟

- 編碼長度不變
  雖然可以減少錯誤，但葛雷碼的長度並不比標準二進制碼短，無法達到壓縮數據的效果

```
1011(2) => gray code, ^: xor
1 0 1 1
     \|
    1^1 = 0
   \|
   0^1 = 1
 \|
  1^0 = 1
|
1 = 1
=> 1110(G)
```

```
1110(G) => binary code
1 1 1 0
|
1
 \|
 1^1 = 0
   \|
   0^1 = 1
     \|
     1^0 = 1
=> 1011(2)
```

---

## 3-6 浮點數表示法

Floating-Point 對比 Fixed-Point

`單精度浮點數 / Single Precision Floating-Point`

單精度浮點數使用 32 bit (4 byte) 來表示一個浮點數

- 符號位 / sign bit (1 bit)
  用來表示數字的正負, 0 表示正數, 1 表示負數

- 偏移指數 / biased exponent (8 bit)
  用來表示數字的指數部分. 採用偏移量表示法 (偏移量為 127), 即實際指數等於存儲的指數值減去 127

- 尾數 / fraction, mantissa (23 bit)
  用來表示數字的尾數部分 (有效數字). 尾數部分通常被視為範圍在 1 到 2 之間的數字 (範圍內的數字加上隱藏的 1)

- 正規化 / Normalization
  將浮點數表示成具有特定格式的數字, 使數字的表示形式唯一且保持最大的精度. 根據 IEEE 754 標準, 單精度浮點數使用 32 bit 表示, 其中包括 1 bit 符號位, 8 bit 指數, 23 bit 尾數位

- 正數範圍
  約在 1.18 x 10 ^ -38 ~ 3.4 x 10 ^ 38

- 負數範圍
  約在 -1.18 x 10 ^ -38 ~ -3.4 x 10 ^ 38

- 精度
  單精度浮點數的精度約為 6 到 7 位十進制數

```
十進制數 3.75 => 單精度浮點數

二進制 3.75(10) => 11.11(2)
正規化 11.11(2) = 1.111 × 2^1 (2)
符號位 正數, sign bit = 0
指數位 指數是 1, 加上偏移量 127, 所以指數位為 128 => 10000000
尾數位 尾數是 0.111 (2) => 11100000000000000000000 (去掉整數 1 後的部分)
0 ∣ 10000000 ∣ 11100000000000000000000
```

```
十進制數 22.5 => 單精度浮點數

二進制 22.5(10) => 10110.1(2)
正規化 10110.1(2) = 1.01101 × 2^4 (2)
符號位 正數, sign bit = 0
指數位 指數是 4, 加上偏移量 127, 所以指數位為 131 => 10000011
尾數位 尾數是 0.01101 (2) => 01101000000000000000000 (去掉整數 1 後的部分)
0 ∣ 10000011 ∣ 01101000000000000000000
```

Truncation Error

Normalized Form

`雙精度浮點數 / Double Precision Floating-Point`

是一種用來表示實數的數字格式，它通常使用 64 bit (8 byte) 來表示一個浮點數

- 符號位 / sign bit (1 bit)
  用來表示數字的正負, 0 表示正數, 1 表示負數

- 偏移指數 / biased exponent (11 bit)
  用來表示數字的指數部分. 採用偏移量表示法 (偏移量為 1023), 即實際指數等於存儲的指數值減去 1023

- 尾數 / fraction, mantissa (52 bit)
  用來表示數字的尾數部分 (有效數字). 尾數部分通常被視為範圍在 1 到 2 之間的數字 (範圍內的數字加上隱藏的 1)

- 範圍
  雙精度浮點數可以表示的範圍大約是 −1.8 × 10 ^ 308 ~ 1.8×10 ^ 308

- 精度
  雙精度浮點數的精度約為 15 到 17 位十進制數

---

## 3-7 文字表示法

### ASCII

### EASCII

### EBCDIC

### Big5

### Unicode

### UTF-8

---

## 3-8 圖形表示法

### bitmap

dpi: dots per inch

ppi: pixels per inch

```
color               bit
黑白                 1
灰階                 2
16 色                4
256 色               8
高彩 / high color    16
全彩 / true color    24
```

```
800x600 全彩 圖片檔案大小
=> 800 * 600 * 24
= 11,520,000 bit
= 11,520,000 / 8 byte
= 1,440,000 B
= 1,440,000 / 1,024 B
= 1,406.25 KB
~ 1.37 MB
~ 1.4 MB
```

### vector

---

## 3-9 聲音表示法

---

## 3-10 視訊表示法

---

## 3-11 資料壓縮

### 3-11-1 重複次數編碼 / RLE, Run Length Encoding

```
AAAABBBCCDAA
=>
A4B3C2DA2
```

- 適用性
  RLE 非常適合壓縮那些有大量重複數據的情況，如黑白圖片、簡單的圖形或圖標。對於這些情況，RLE 可以顯著減少數據量

- 壓縮比
  RLE 的壓縮比取決於數據中重複元素的數量。如果數據中重複的部分很多，RLE 的壓縮比會很高；但如果數據較為隨機且重複部分較少，RLE 可能無法提供良好的壓縮效果，甚至可能增加數據量

- 簡單性
  RLE 是一種非常簡單的壓縮算法，實現起來非常容易，且解壓縮的過程也非常快速

### 3-11-2 霍夫曼編碼 / Huffman Coding

`原理`

1. 統計符號頻率
   計算資料中每個符號的出現頻率，並將這些符號和對應的頻率組成一個優先隊列或小頂堆

2. 構建霍夫曼樹
   從優先隊列中取出兩個頻率最低的符號作為二元樹的左右子節點，並將它們的頻率相加作為新節點的頻率，將新節點插回優先隊列
   重複這一過程，直到所有符號都被合併到一棵樹中。這棵樹被稱為霍夫曼樹

3. 生成編碼
   在霍夫曼樹中，從根節點到每個葉節點的路徑生成對應符號的編碼。通常，向左子節點移動表示「0」，向右子節點移動表示「1」

4. 編碼與解碼
   使用生成的霍夫曼編碼表對資料進行編碼。解碼時，根據霍夫曼樹的結構從編碼字串還原原始資料

`應用`

- JPEG
  圖像壓縮格式，使用霍夫曼編碼來壓縮圖像資料

- MP3
  音頻壓縮格式，使用霍夫曼編碼來壓縮音頻資料

- ZIP
  通用壓縮格式，使用霍夫曼編碼來壓縮各類型的文件資料

`優點`

- 壓縮效率高，特別是對於符號頻率差異較大的資料集
- 編碼與解碼都相對簡單且高效

`缺點`

- 需要提前知道符號的頻率分佈才能生成霍夫曼樹，這在一些動態或實時壓縮應用中可能不方便
- 對於某些資料集（如頻率分佈均勻的符號），霍夫曼編碼的壓縮效果可能不如其他編碼方法，如算術編碼

```
AAAABBBCCDAA
D(1), C(2), B(3), A(6)
=> C-D (3)
B-(C-D)(6)
A-(B(C-D))(16)

     (12)
   0 /  \  1
   A(6)  (6)
      0  / \  1
      B(3)  (3)
          0 / \  1
          C(2) D(1)
A: 0
B: 10
C: 110
D: 111
A      B        C        D     A
0000 | 101010 | 110110 | 111 | 00
```

---

## 3-12 誤差與錯誤檢查
